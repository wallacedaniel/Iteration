
/*
let bug; // Declare object

function setup() {
  createCanvas(710, 400);
  // Create object
  bug = new Jitter();
}

function draw() {
  background(50, 89, 100);
  bug.move();
  bug.display();
}

// Jitter class
class Jitter {
  constructor() {
    this.x = random(width);
    this.y = random(height);
    this.diameter = random(10, 30);
    this.speed = 1;
  }

  move() {
    this.x += random(-this.speed, this.speed);
    this.y += random(-this.speed, this.speed);
  }

  display() {
    ellipse(this.x, this.y, this.diameter, this.diameter);
  }
}



let bug1; // Declare objects
let bug2;
let bug3;
let bug4;

function setup() {
  createCanvas(710, 400);
  // Create object
  bug1 = new Jitter();
  bug2 = new Jitter();
  bug3 = new Jitter();
  bug4 = new Jitter();
}

function draw() {
  background(50, 89, 100);
  bug1.move();
  bug1.display();
  bug2.move();
  bug2.display();
  bug3.move();
  bug3.display();
  bug4.move();
  bug4.display();
}

// Jitter class
class Jitter {
  constructor() {
    this.x = random(width);
    this.y = random(height);
    this.diameter = random(10, 30);
    this.speed = 1;
  }

  move() {
    this.x += random(-this.speed, this.speed);
    this.y += random(-this.speed, this.speed);
  }

  display() {
    ellipse(this.x, this.y, this.diameter, this.diameter);
  }
}



let bugs = []; // array of Jitter objects

function setup() {
  createCanvas(2600, 40000);
  // Create objects
  for (let i = 0; i < 50; i++) {
    bugs.push(new Jitter());
  }
}

function draw() {
  background(50, 89, 100);
  for (let i = 0; i < bugs.length; i++) {
    bugs[i].move();
    bugs[i].display();
  }
}

// Jitter class
class Jitter {
  constructor() {
    this.x = random(width);
    this.y = random(height);
    this.diameter = random(10, 30);
    this.speed = 1;
  }

  move() {
    this.x += random(-this.speed, this.speed);
    this.y += random(-this.speed, this.speed);
  }

  display() {
    ellipse(this.x, this.y, this.diameter, this.diameter);
  }
}
*/
/*
class Canvas {
  constructor() {
    this.W;
    this.H;
    this.coordinates;
  }
}


class Canvas {

  int W;
  int H;
  ArrayList<int[]> coordinates;
  
  // Random Grid Canvas constrained by bounds square option
  Canvas(float[] bounds, boolean square){
    // Gets all possible grid ratios
    IntList[] canvasD = createGrids(bounds[0], bounds[1], bounds[2], bounds[3]);
    int[] gridD = new int[2];
    //...selects random pair...    
    if(square == true) {
      gridD = getSquares(canvasD);
    }
    else {
      gridD = getDimensions(canvasD);      
    }  
    //... sets W and H
    this.W = gridD[0];
    this.H = gridD[1];
    
    // Creates array of grid coordinates
    ArrayList<int[]> coordinatesArray = new ArrayList<int[]>();
    
    for (int x = 0; x <= width; x += W) {
      for (int y = 0; y < height + H; y += H) {
        
        //creates cell coordinates [top L x, top L y, center x, center y]
        int[] newCoordinates = new int[4];
        newCoordinates[0] = x;
        newCoordinates[1] = y;
        newCoordinates[2] = x + W/2;
        newCoordinates[3] = y + H/2;
        coordinatesArray.add(newCoordinates);
      }
    }
    this.coordinates = coordinatesArray;
  }
  
   // random point between where and where - [4]xMin xMax yMin yMax
   Canvas(float[] coordBounds, int qty){
     
     ArrayList<int[]> coordinatesArray = new ArrayList<int[]>();
     
     for(int i = 0; i < qty; i++){
       int[] newCoordinates = new int[2];
       int x = int(random(coordBounds[0],coordBounds[1]+1));
       int y = int(random(coordBounds[2],coordBounds[3]+1));
        newCoordinates[0] = x;
        newCoordinates[1] = y;
        coordinatesArray.add(newCoordinates);
     }
     this.coordinates = coordinatesArray;
   }
   
   Canvas(){
       
     ArrayList<int[]> coordinatesArray = new ArrayList<int[]>();
     
       int[] newCoordinates = new int[]{0,0}; 
       coordinatesArray.add(newCoordinates);
       newCoordinates = new int[]{0,width};
       coordinatesArray.add(newCoordinates);
       newCoordinates = new int[]{width,height};
       coordinatesArray.add(newCoordinates);
       newCoordinates = new int[]{0,height};
       coordinatesArray.add(newCoordinates);
       newCoordinates = new int[]{width/2,height/2};
       coordinatesArray.add(newCoordinates);// levels * + ?        
       this.coordinates = coordinatesArray; 
   }
   
// returns two IntList[]'s of all evenly divisible Widths and Heights for Canvas - constrained by Upper and Lower Bounds
  IntList[] createGrids(float innerWBound, float outerWBound, float innerHBound, float outerHBound) {
    IntList[] canvasD = new IntList[2];
    IntList widthDivs = new IntList();
    for(int i = 1;i <= width;i++){
      
      if(width%i == 0 && i >= (width * innerWBound) && i <= (width * outerWBound)){
        widthDivs.append(i);
      }
    }
    IntList heightDivs = new IntList();
    for(int i = 1;i <= height;i++){
      if(height%i == 0 && i >= (height * innerHBound) && i <= (height * outerHBound)){
        heightDivs.append(i);
      }
    }
    canvasD[0] = widthDivs;
    canvasD[1] = heightDivs;
    return canvasD;
  }
  
  // Returns random W and H values for grid                 
  int[] getDimensions(IntList[] canvasD){
    int[] gridD = new int[2];
    int indexW = floor(random(0,canvasD[0].maxIndex()));
    int indexH = floor(random(0,canvasD[1].maxIndex()));
    gridD[0] = canvasD[0].get(indexW);
    gridD[1] = canvasD[1].get(indexH);
    return gridD;
  }
  
  // Returns random W and H values for grid - constrained to squares
  int[] getSquares(IntList[] canvasD){
  
    IntList commonDimensions = new IntList();  
    int[] gridD = new int[2];  
    
    for(int i = 0; i < canvasD[0].size(); i++){      
      if(canvasD[1].hasValue(canvasD[0].get(i))){ 
        
        commonDimensions.append(canvasD[0].get(i));
      }     
    }
    int squareIndex = int(random(0, commonDimensions.size()));
    gridD[0] = commonDimensions.get(squareIndex);
    gridD[1] = gridD[0];
    return gridD;
  }
}

*/























































/*


let r1, r2, r3, r4;

function setup() {
  createCanvas(710, 400);
  fill(255, 204);
  noStroke();
  r1 = new MRect(1, 134.0, 0.532, 0.1 * height, 10.0, 60.0);
  r2 = new MRect(2, 44.0, 0.166, 0.3 * height, 5.0, 50.0);
  r3 = new MRect(2, 58.0, 0.332, 0.4 * height, 10.0, 35.0);
  r4 = new MRect(1, 120.0, 0.0498, 0.9 * height, 15.0, 60.0);
}

function draw() {
  background(0);

  r1.display();
  r2.display();
  r3.display();
  r4.display();

  r1.move(mouseX - width / 2, mouseY + height * 0.1, 30);
  r2.move((mouseX + width * 0.05) % width, mouseY + height * 0.025, 20);
  r3.move(mouseX / 4, mouseY - height * 0.025, 40);
  r4.move(mouseX - width / 2, height - mouseY, 50);
}

class MRect {
  constructor(iw, ixp, ih, iyp, id, it) {
    this.w = iw; // single bar width
    this.xpos = ixp; // rect xposition
    this.h = ih; // rect height
    this.ypos = iyp; // rect yposition
    this.d = id; // single bar distance
    this.t = it; // number of bars
  }

  move(posX, posY, damping) {
    let dif = this.ypos - posY;
    if (abs(dif) > 1) {
      this.ypos -= dif / damping;
    }
    dif = this.xpos - posX;
    if (abs(dif) > 1) {
      this.xpos -= dif / damping;
    }
  }

  display() {
    for (let i = 0; i < this.t; i++) {
      rect(
        this.xpos + i * (this.d + this.w),
        this.ypos,
        this.w,
        height * this.h
      );
    }
  }
}




*/



let slider;

function setup() {
  createCanvas(400, 400);
  slider = createSlider(0, 10, 2, 0.01);
}

function draw() {
  background(51);
  translate(width / 2, height / 2);

  let a = 100;
  let b = 100;
  let n = slider.value();
  stroke(255);
  noFill();

  beginShape();
  for (let angle = 0; angle < TWO_PI; angle += 0.1) {
    // Simple ellipse
    // let x = r * cos(angle);
    // let y = r * sin(angle);

    // Superellipse
    let na = 2 / n;
    let x = pow(abs(cos(angle)), na) * a * sgn(cos(angle));
    let y = pow(abs(sin(angle)), na) * b * sgn(sin(angle));
    vertex(x, y);
  }
  endShape(CLOSE);
}

function sgn(val) {
  if (val == 0) {
    return 0;
  }
  return val / abs(val);
}









































